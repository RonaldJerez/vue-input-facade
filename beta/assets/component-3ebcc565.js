import{p as O,q as M,d as _,e as z}from"./vue.esm-bundler-80178e97.js";const B={"#":{pattern:/\d/},X:{pattern:/[0-9a-z]/i},S:{pattern:/[a-z]/i},A:{pattern:/[a-z]/i,transform:e=>e.toLocaleUpperCase()},a:{pattern:/[a-z]/i,transform:e=>e.toLocaleLowerCase()},"\\":{escape:!0},"?":{optional:!0},"*":{repeat:!0},"|":{pipe:!0}};let V=B,j=!1;try{"a".localeCompare("b","i")}catch(e){j=e.name==="RangeError"}function R(e){e&&(V=e)}function H(e,t){const n=t.masks.slice().sort((o,m)=>o.length-m.length),a=o=>Object.assign({},t,o),s=(o,m)=>{const u=C(e,a({mask:m})),p=o.unmasked.length;return u.unmasked.length>p?u:o};if(!n.length)return new E;const i=n.shift();let r=C(e,a({mask:i}));for(;n.length;){const o=n.shift();r=s(r,o)}return r}function C(e,t){var c,L;let{mask:n="",tokens:a,prefill:s=!1,short:i=!1}=t;a=a?Object.assign({},V,a):V;let r=new E,o=!1,m=0,u=0,p="";function d(h){const k=n[u+1],l=a[k];return{escape:!!(h!=null&&h.escape),optional:!!(l!=null&&l.optional),repeat:!!(l!=null&&l.repeat),...(l==null?void 0:l.pipe)&&{pipe:n.substring(u).match(/^(.\|)+./g)[0].split("|")}}}for(;u<n.length;){const h=n[u],k=a[h];let l=e[m];const f=d(k);if(k&&!o&&!f.pipe){if(f.escape){o=!0,u++;continue}if(!l)break;if((c=k.pattern)!=null&&c.test(l))l=((L=k.transform)==null?void 0:L.call(k,l))||l,r.unmasked+=l,r.masked+=p+l,p="",f.repeat||(u+=f.optional?2:1);else if(f.optional||f.repeat){u+=2;continue}m++}else if(f.pipe){if(!l)break;const b=f.pipe.find(T.bind(null,l));b&&(r.unmasked+=b,r.masked+=p+b,u+=f.pipe.length*2-1,p=""),m++}else T(l,h)?(r.masked+=p+h,m++,p="",f.optional&&(r.unmasked+=h)):f.optional||(p+=h),o=!1,u+=f.optional?2:1}return(s&&!r.unmasked||!i&&r.unmasked)&&(r.masked+=p),r}function T(e,t){return j?(e==null?void 0:e.localeCompare(t,void 0,{sensitivity:"base"}))===0:(e==null?void 0:e.toLocaleLowerCase())===(t==null?void 0:t.toLocaleLowerCase())}function F(e,t){return e=(e||"").toString(),t=I(t),t.mask?Array.isArray(t.mask)?H(e,Object.assign({},t,{masks:t.mask})):C(e,t):new E(e)}const g="__input-facade__";function E(e){this.masked=this.unmasked=e||""}function x(){return new CustomEvent("input",{bubbles:!0,cancelable:!0,detail:{facade:!0}})}function I(e,t){return(Array.isArray(e)||typeof e=="string")&&(e={mask:e}),Object.assign(e||{},t)}function y(e){const t=e instanceof HTMLInputElement?e:e.querySelector("input");if(!t)throw new Error("facade directive requires an input element");return t}function S(e,t){const{target:n,detail:a,inputType:s}=e;if(a!=null&&a.facade||(e.stopPropagation(),["insertCompositionText","insertFromComposition"].includes(s)&&t[g].config.mask))return!1;const i=n.value,r=n.selectionEnd,{oldValue:o}=n[g];w(n,null,{emit:!1},e),K(e,i,r),o!==n.value&&n.dispatchEvent(x())}function K(e,t,n){const{target:a}=e,s=["text","tel","search",null].includes(a.getAttribute("type")),i=a[g]&&a[g].config;if(a!==document.activeElement||!s||!i.mask&&!i.masked)return;const r=e.inputType||"insertText",o=["insertText","insertFromPaste"].includes(r),m=o&&n==t.length;let u=o&&t[n-1];const p=a.value.toLocaleLowerCase();let d=n;if(m)d=p.length;else if(u){u=u.toLocaleLowerCase();let c=d;for(;c<=p.length&&p.charAt(c-1)!==u;)c++;d=c<=p.length?c:d-1}a.setSelectionRange(d,d),setTimeout(function(){a.setSelectionRange(d,d)},0)}function w(e,t,{emit:n=!0,force:a=!1}={},s){var u,p;let{config:i,oldValue:r,isComposing:o}=e[g],m=((p=(u=t==null?void 0:t.data)==null?void 0:u.model)==null?void 0:p.value)||e.value;if(!(i.mask&&o)&&(r=r||"",m=m||"",a||r!==m)){["deleteByCut","deleteContent","deleteContentBackward","deleteContentForward"].includes(s==null?void 0:s.inputType)&&(i={...i,short:!0});let d=F(m,i);if(s&&typeof i.formatter=="function"){const c=i.formatter(d,s);if(typeof c=="string")d=F(c,i);else if(c===!1){e.value=r;return}}e[g].oldValue=d.masked,e.unmaskedValue=d.unmasked,e.value!==d.masked&&(e.value=d.masked),n&&e.dispatchEvent(x())}}const v=g,N={beforeMount:(e,{value:t,modifiers:n},a)=>{e=y(e);const s=I(t,n);e[v]={config:s},w(e,a,{force:s.prefill})},mounted:e=>{e=y(e);const t=e[v],n=e.parentElement||e,a=i=>{i.target===e&&S(i,e)},s=i=>{i.target===e&&(i.type==="compositionend"?(e[v].isComposing=!1,S(i,e)):e[v].isComposing=!0)};n.addEventListener("input",a,!0),n.addEventListener("compositionstart",s,!0),n.addEventListener("compositionupdate",s,!0),n.addEventListener("compositionend",s,!0),t.cleanup=()=>{n.removeEventListener("input",a,!0),n.removeEventListener("compositionstart",s,!0),n.removeEventListener("compositionend",s,!0),n.removeEventListener("compositionupdate",s,!0)}},updated:(e,{value:t,oldValue:n,modifiers:a},s)=>{e=y(e),t!==n?(e[v].config=I(t,a),w(e,s,{force:!0})):w(e,s)},unmounted:e=>{y(e)[v].cleanup()}},P=(e,t)=>{const n=e.__vccOpts||e;for(const[a,s]of t)n[a]=s;return n},A={name:"InputFacade",directives:{facade:N},props:{formatter:{type:Function,default:null},mask:{type:[String,Array],default:null},masked:{type:Boolean,default:!1},prefill:{type:Boolean,default:!1},short:{type:Boolean,default:!1},tokens:{type:Object,default:()=>({})},modelValue:{type:[String,Number],default:""},modelModifiers:{type:Object,default:()=>({})}},emits:["update:model-value","change","keydown","keyup","paste"],data(){return{maskedValue:this.modelValue,unmaskedValue:null}},computed:{config(){return{mask:this.mask,masked:this.masked,tokens:this.tokens,formatter:this.formatter,prefill:this.prefill,short:this.short}},emittedValue(){return this.mask&&this.masked?this.maskedValue:this.unmaskedValue}},watch:{modelValue(e){e!==this.emittedValue&&(this.maskedValue=e)},mask:{deep:!0,handler(e){!e&&!this.masked&&(this.maskedValue=this.unmaskedValue)}},masked(){this.emitInput()}},methods:{onInput({target:e}){this.maskedValue=e.value,this.unmaskedValue=e.unmaskedValue,this.modelModifiers.lazy||this.emitInput()},onChange(){this.$emit("change",this.emittedValue),this.modelModifiers.lazy&&this.emitInput()},emitInput(){this.$emit("update:model-value",this.emittedValue)}}},D=["value"];function $(e,t,n,a,s,i){const r=O("facade");return M((_(),z("input",{type:"text",value:s.maskedValue,onInput:t[0]||(t[0]=(...o)=>i.onInput&&i.onInput(...o)),onChange:t[1]||(t[1]=(...o)=>i.onChange&&i.onChange(...o)),onKeyup:t[2]||(t[2]=o=>e.$emit("keyup",o)),onKeydown:t[3]||(t[3]=o=>e.$emit("keydown",o)),onPaste:t[4]||(t[4]=o=>e.$emit("paste",o))},null,40,D)),[[r,i.config]])}const U=P(A,[["render",$]]);A.__docgenInfo={displayName:"InputFacade",description:`The component is basically a wrapper around a native input element, as such it inherits all
properties available to [HTMLInputElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement).

However it provides a cleaner and more straight forward interface to the directive's features.`,tags:{examples:[{title:"example",content:"file://./stories/docs/component/component.mdx"}]},exportName:"default",props:[{name:"formatter",description:`A function to format the value after applying the mask. The function will receive an
object with the masked and unmasked value. The result of this function will determine
what happens with the value.
<br />
If a string is returned, then that string will pass through the masker function once more and its value
will be set to the input. If false (boolean) is returned, the input will be rejected and the
previous value will be restored. Otherwise the facade logic will continue as usual.`,tags:{since:[{description:"v1.3",title:"since"}]},type:{name:"func"},defaultValue:{func:!1,value:"null"}},{name:"mask",description:"The mask pattern for this input, it could be a single pattern or multiple patterns when its an array.",type:{name:"string|array"},defaultValue:{func:!1,value:"null"}},{name:"masked",description:"Whether to emit the value masked or unmasked",type:{name:"boolean"},defaultValue:{func:!1,value:"false"}},{name:"prefill",description:"If the mask starts with static charaters, prefill the field with said characters",tags:{since:[{description:"v1.3",title:"since"}]},type:{name:"boolean"},defaultValue:{func:!1,value:"false"}},{name:"short",description:"Keep the value short by not showing static characters until after typing",tags:{since:[{description:"v1.3",title:"since"}]},type:{name:"boolean"},defaultValue:{func:!1,value:"false"}},{name:"tokens",description:"Token object to override the defaults with",type:{name:"object"},defaultValue:{func:!1,value:"{}"}},{name:"v-model",description:"The input's value",tags:{model:[{description:!0,title:"model"}]},type:{name:"string|number"},defaultValue:{func:!1,value:"''"}},{name:"modelModifiers",type:{name:"object"},defaultValue:{func:!1,value:"{}"}}],events:[{name:"keyup"},{name:"keydown"},{name:"paste"},{name:"update:model-value",type:{names:["undefined"]},description:"Fires when the value of the input has been changed.",properties:[{type:{names:["String"]},name:"value",description:"The input's current value, masked or unmasked."}],tags:[{title:"param",type:{name:"String"},name:"value",description:"The input's current value, masked or unmasked."}]},{name:"change",type:{names:["undefined"]},description:"Fires when the value has been commited on the input. Usually on blur.",properties:[{type:{names:["String"]},name:"value",description:"The input's current value, masked or unmasked."}],tags:[{title:"param",type:{name:"String"},name:"value",description:"The input's current value, masked or unmasked."}]}],sourceFiles:["/home/runner/work/vue-input-facade/vue-input-facade/src/component.vue"]};export{U as I,N as f,F as m,R as s};
